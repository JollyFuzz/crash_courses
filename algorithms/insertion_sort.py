def insertion_sort(a):
    if len(a) < 2:
        return a
    
    l = len(a) - 1
    
    # Начинаем с первого элемента массива
    # Нулевой элемент уже считаем отсортированным
    i = 1

    while i <= l:
        # текущий индекс внешнего цикла, список слева от этого элемента отсортирован
        j = i
        # Ищем для текущего элемента место в левой части уже отсортированного массива, обходя список в обратном порядке
        while j != 0:
            # если предыдущий элемент меньше или равен текущему элементу, то элемент уже находится на своем месте
            # и из цикла можно выходить 
            if a[j - 1] <= a[j]:
                break
            
            # в противном случае
            # меняем элементы местами. Эта операция сложности O(1) проще и дешевле, чем потом пересоздавать список
            a[j-1], a[j] = a[j], a[j-1]
            j -= 1

        i += 1


    return a